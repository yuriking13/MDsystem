generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String    @id @default(dbgenerated("gen_random_uuid()"))
  email        String    @unique
  passwordHash String    @map("password_hash")
  createdAt    DateTime  @default(now()) @map("created_at")
  lastLoginAt  DateTime? @map("last_login_at")

  projectsOwned     Project[]          @relation("OwnerProjects")
  memberships       ProjectMember[]
  createdStatistics ProjectStatistic[]
  createdDocuments  Document[]
  addedArticles     ProjectArticle[]
  apiKeys           UserApiKey[]
  uploadedFiles     ProjectFile[]

  @@map("users")
}

model UserApiKey {
  id           Int      @id @default(autoincrement())
  userId       String   @map("user_id")
  provider     String
  encryptedKey String   @map("encrypted_key")
  createdAt    DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@map("user_api_keys")
}

model Project {
  id          String  @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  description String?

  createdBy String? @map("created_by")
  owner     User?   @relation("OwnerProjects", fields: [createdBy], references: [id])

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")
  citationStyle String   @default("gost-r-7-0-5-2008") @map("citation_style")
  language      String?  @default("ru")

  // Research fields
  researchType           String?  @map("research_type")
  researchSubtype        String?  @map("research_subtype")
  researchProtocol       String?  @map("research_protocol")
  protocolCustomName     String?  @map("protocol_custom_name")
  aiErrorAnalysisEnabled Boolean? @default(false) @map("ai_error_analysis_enabled")
  aiProtocolCheckEnabled Boolean? @default(false) @map("ai_protocol_check_enabled")

  members    ProjectMember[]
  documents  Document[]
  articles   ProjectArticle[]
  statistics ProjectStatistic[]
  queries    SearchQuery[]
  graphFetchJobs GraphFetchJob[]
  files      ProjectFile[]

  @@map("projects")
}

model ProjectMember {
  projectId String   @map("project_id")
  userId    String   @map("user_id")
  role      String   @default("viewer")
  joinedAt  DateTime @default(now()) @map("joined_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([projectId, userId])
  @@map("project_members")
}

model Article {
  id                  String    @id @default(dbgenerated("gen_random_uuid()"))
  doi                 String?   @unique
  pmid                String?   @unique
  titleEn             String    @map("title_en")
  abstractEn          String?   @map("abstract_en")
  titleRu             String?   @map("title_ru")
  abstractRu          String?   @map("abstract_ru")
  authors             String[] // TEXT[]
  year                Int?      @db.SmallInt
  journal             String?
  publicationType     String?   @map("publication_type")
  publicationTypes    String[]  @default([]) @map("publication_types")
  url                 String?
  source              String
  hasStats            Boolean   @default(false) @map("has_stats")
  statsJson           Json?     @map("stats_json")
  rawJson             Json?     @map("raw_json")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")
  referencePmids      String[]  @default([]) @map("reference_pmids")
  citedByPmids        String[]  @default([]) @map("cited_by_pmids")
  referenceDois       String[]  @default([]) @map("reference_dois")
  crossrefCitedByCount Int?     @map("crossref_cited_by_count")
  referencesFetchedAt DateTime? @map("references_fetched_at")
  statsQuality        Int?      @default(0) @map("stats_quality")
  volume              String?
  issue               String?
  pages               String?
  searchQueries       String[]  @default([]) @map("search_queries")
  
  // Import from file support
  sourceFileId           String?  @map("source_file_id")
  extractedBibliography  Json?    @map("extracted_bibliography")
  isFromFile             Boolean  @default(false) @map("is_from_file")

  projectArticles ProjectArticle[]
  citations       Citation[]

  @@map("articles")
}

model ProjectArticle {
  projectId   String   @map("project_id")
  articleId   String   @map("article_id")
  status      String   @default("candidate")
  notes       String?
  tags        String[] @default([])
  addedBy     String?  @map("added_by")
  addedAt     DateTime @default(now()) @map("added_at")
  sourceQuery String?  @map("source_query")
  
  // Track if imported from file (article persists even if file is deleted)
  importedFromFileId String?   @map("imported_from_file_id")
  fileImportDate     DateTime? @map("file_import_date")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [addedBy], references: [id])

  @@id([projectId, articleId])
  @@map("project_articles")
}

model Document {
  id         String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId  String   @map("project_id")
  title      String
  content    String? // TEXT
  orderIndex Int      @default(0) @map("order_index")
  parentId   String?  @map("parent_id")
  createdBy  String?  @map("created_by")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")
  version    Int      @default(1) // Optimistic locking

  project Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parent  Document? @relation("DocHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Document[] @relation("DocHierarchy")
  creator User?     @relation(fields: [createdBy], references: [id])
  citations Citation[]

  @@map("documents")
}

model Citation {
  id           String   @id @default(dbgenerated("gen_random_uuid()"))
  documentId   String   @map("document_id")
  articleId    String   @map("article_id")
  orderIndex   Int      @default(0) @map("order_index")
  inlineNumber Int?     @map("inline_number")
  subNumber    Int?     @default(1) @map("sub_number")
  pageRange    String?  @map("page_range")
  note         String?
  createdAt    DateTime @default(now()) @map("created_at")

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  article  Article  @relation(fields: [articleId], references: [id])

  @@map("citations")
}

model ProjectStatistic {
  id                 String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId          String   @map("project_id")
  type               String // chart, table
  title              String
  description        String?
  config             Json
  tableData          Json?    @map("table_data")
  dataClassification Json?    @map("data_classification")
  chartType          String?  @map("chart_type")
  usedInDocuments    String[] @map("used_in_documents")
  orderIndex         Int      @default(0) @map("order_index")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at")
  createdBy          String?  @map("created_by")
  version            Int      @default(1) // Optimistic locking

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User?   @relation(fields: [createdBy], references: [id])

  @@index([projectId])
  @@index([type])
  @@index([chartType])
  @@map("project_statistics")
}

model SearchQuery {
  id        String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId String   @map("project_id")
  topic     String
  filters   Json
  status    String   @default("queued")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("search_queries")
}

// Кэш данных о статьях для графа цитирований
model GraphCache {
  pmid          String    @id
  title         String?
  authors       String?
  year          Int?
  doi           String?
  referencePmids String[] @default([]) @map("reference_pmids")
  citedByPmids   String[] @default([]) @map("cited_by_pmids")
  citationCount  Int?     @map("citation_count")
  fetchedAt     DateTime? @map("fetched_at")
  expiresAt     DateTime? @default(dbgenerated("now() + interval '30 days'")) @map("expires_at")
  projectId     String?   @map("project_id")

  @@index([projectId])
  @@index([expiresAt])
  @@map("graph_cache")
}

// Отслеживание прогресса загрузки связей из PubMed
model GraphFetchJob {
  id                 String    @id @default(dbgenerated("gen_random_uuid()"))
  projectId          String    @map("project_id")
  status             String    @default("pending") // pending, running, completed, failed, cancelled
  totalArticles      Int       @default(0) @map("total_articles")
  processedArticles  Int       @default(0) @map("processed_articles")
  totalPmidsToFetch  Int       @default(0) @map("total_pmids_to_fetch")
  fetchedPmids       Int       @default(0) @map("fetched_pmids")
  startedAt          DateTime? @map("started_at")
  completedAt        DateTime? @map("completed_at")
  lastProgressAt     DateTime? @map("last_progress_at") // Время последнего обновления прогресса
  cancelledAt        DateTime? @map("cancelled_at") // Время отмены
  cancelReason       String?   @map("cancel_reason") // stalled, user_cancelled, timeout
  errorMessage       String?   @map("error_message")
  createdAt          DateTime  @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([status])
  @@map("graph_fetch_jobs")
}

// Файлы проекта (хранятся в S3-совместимом хранилище)
model ProjectFile {
  id              String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId       String   @map("project_id")
  name            String   // Оригинальное имя файла
  storagePath     String   @map("storage_path") // Путь в S3: {projectId}/{uuid}.{ext}
  mimeType        String   @map("mime_type")
  size            Int      // Размер в байтах
  category        String   @default("other") // document, image, video, audio, other
  description     String?
  usedInDocuments String[] @default([]) @map("used_in_documents") // ID документов где используется
  uploadedBy      String?  @map("uploaded_by")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @default(now()) @updatedAt @map("updated_at")

  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  uploader User?   @relation(fields: [uploadedBy], references: [id])

  @@index([projectId])
  @@index([category])
  @@map("project_files")
}
