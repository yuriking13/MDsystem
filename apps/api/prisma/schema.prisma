generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String    @id @default(dbgenerated("gen_random_uuid()"))
  email                 String    @unique
  passwordHash          String    @map("password_hash")
  createdAt             DateTime  @default(now()) @map("created_at")
  lastLoginAt           DateTime? @map("last_login_at")
  isAdmin               Boolean   @default(false) @map("is_admin")
  adminTokenHash        String?   @map("admin_token_hash") @db.VarChar(255)
  isBlocked             Boolean   @default(false) @map("is_blocked")
  blockedReason         String?   @map("blocked_reason")
  blockedAt             DateTime? @map("blocked_at")
  passwordResetRequired Boolean   @default(false) @map("password_reset_required")

  projectsOwned     Project[]          @relation("OwnerProjects")
  memberships       ProjectMember[]
  createdStatistics ProjectStatistic[]
  createdDocuments  Document[]
  addedArticles     ProjectArticle[]
  apiKeys           UserApiKey[]
  uploadedFiles     ProjectFile[]
  activities        UserActivity[]
  sessions          UserSession[]
  refreshTokens     RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  subscriptions     UserSubscription[]
  adminAuditLogs    AdminAuditLog[]
  resolvedErrors    SystemErrorLog[]   @relation("ResolvedBy")
  userErrors        SystemErrorLog[]   @relation("UserErrors")
  medSubmissionsAuthored MedPublisherSubmission[] @relation("MedPublisherSubmissionAuthor")
  medSubmissionsHandled  MedPublisherSubmission[] @relation("MedPublisherHandlingEditor")
  medPublisherReviews    MedPublisherReview[]     @relation("MedPublisherReviewReviewer")
  medPublisherEvents     MedPublisherTimelineEvent[] @relation("MedPublisherEventActor")
  medPublisherEditorProfile MedPublisherEditor?   @relation("MedPublisherEditorUser")
  grantedMedPublisherEditors MedPublisherEditor[] @relation("MedPublisherEditorGrantedBy")

  @@map("users")
}

model UserApiKey {
  id           Int      @id @default(autoincrement())
  userId       String   @map("user_id")
  provider     String
  encryptedKey String   @map("encrypted_key")
  createdAt    DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@map("user_api_keys")
}

model RefreshToken {
  id        String   @id @default(dbgenerated("gen_random_uuid()::text"))
  userId    String   @map("user_id")
  tokenHash String   @unique @map("token_hash") @db.VarChar(64)
  expiresAt DateTime @map("expires_at")
  revoked   Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([revoked, expiresAt])
  @@index([userId, revoked, createdAt])
  @@map("refresh_tokens")
}

model PasswordResetToken {
  id        String    @id @default(dbgenerated("gen_random_uuid()::text"))
  userId    String    @map("user_id")
  tokenHash String    @unique @map("token_hash") @db.VarChar(64)
  expiresAt DateTime  @map("expires_at")
  used      Boolean   @default(false)
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@index([used, expiresAt])
  @@map("password_reset_tokens")
}

model Project {
  id          String  @id @default(dbgenerated("gen_random_uuid()"))
  name        String
  description String?

  createdBy String? @map("created_by")
  owner     User?   @relation("OwnerProjects", fields: [createdBy], references: [id])

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @updatedAt @map("updated_at")
  citationStyle String   @default("gost-r-7-0-5-2008") @map("citation_style")
  language      String?  @default("ru")

  // Research fields
  researchType           String?  @map("research_type")
  researchSubtype        String?  @map("research_subtype")
  researchProtocol       String?  @map("research_protocol")
  protocolCustomName     String?  @map("protocol_custom_name")
  aiErrorAnalysisEnabled Boolean? @default(false) @map("ai_error_analysis_enabled")
  aiProtocolCheckEnabled Boolean? @default(false) @map("ai_protocol_check_enabled")
  autoGraphSyncEnabled   Boolean? @default(false) @map("auto_graph_sync_enabled")

  members    ProjectMember[]
  documents  Document[]
  articles   ProjectArticle[]
  statistics ProjectStatistic[]
  queries    SearchQuery[]
  graphFetchJobs GraphFetchJob[]
  files      ProjectFile[]
  publisherSubmissions MedPublisherSubmission[] @relation("MedPublisherSubmissionProject")

  @@map("projects")
}

model ProjectMember {
  projectId String   @map("project_id")
  userId    String   @map("user_id")
  role      String   @default("viewer")
  joinedAt  DateTime @default(now()) @map("joined_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([projectId, userId])
  @@map("project_members")
}

model Article {
  id                  String    @id @default(dbgenerated("gen_random_uuid()"))
  doi                 String?   @unique
  pmid                String?   @unique
  titleEn             String    @map("title_en")
  abstractEn          String?   @map("abstract_en")
  titleRu             String?   @map("title_ru")
  abstractRu          String?   @map("abstract_ru")
  authors             String[] // TEXT[]
  year                Int?      @db.SmallInt
  journal             String?
  publicationType     String?   @map("publication_type")
  publicationTypes    String[]  @default([]) @map("publication_types")
  url                 String?
  source              String
  hasStats            Boolean   @default(false) @map("has_stats")
  statsJson           Json?     @map("stats_json")
  rawJson             Json?     @map("raw_json")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")
  referencePmids      String[]  @default([]) @map("reference_pmids")
  citedByPmids        String[]  @default([]) @map("cited_by_pmids")
  referenceDois       String[]  @default([]) @map("reference_dois")
  crossrefCitedByCount Int?     @map("crossref_cited_by_count")
  referencesFetchedAt DateTime? @map("references_fetched_at")
  statsQuality        Int?      @default(0) @map("stats_quality")
  volume              String?
  issue               String?
  pages               String?
  searchQueries       String[]  @default([]) @map("search_queries")
  
  // Import from file support
  sourceFileId           String?  @map("source_file_id")
  extractedBibliography  Json?    @map("extracted_bibliography")
  isFromFile             Boolean  @default(false) @map("is_from_file")

  projectArticles ProjectArticle[]
  citations       Citation[]

  @@map("articles")
}

model ProjectArticle {
  projectId   String   @map("project_id")
  articleId   String   @map("article_id")
  status      String   @default("candidate")
  notes       String?
  tags        String[] @default([])
  addedBy     String?  @map("added_by")
  addedAt     DateTime @default(now()) @map("added_at")
  sourceQuery String?  @map("source_query")
  
  // Track if imported from file (article persists even if file is deleted)
  importedFromFileId String?   @map("imported_from_file_id")
  fileImportDate     DateTime? @map("file_import_date")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [addedBy], references: [id])

  @@id([projectId, articleId])
  @@map("project_articles")
}

model MedPublisherSubmission {
  id          String    @id @default(dbgenerated("gen_random_uuid()"))
  title       String
  abstract    String?
  keywords    String[]  @default([])
  manuscript  String?
  status      String    @default("draft")
  createdBy   String    @map("created_by")
  handlingEditorId String? @map("handling_editor_id")
  projectId   String?   @map("project_id")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @default(now()) @updatedAt @map("updated_at")
  submittedAt DateTime? @map("submitted_at")
  decisionAt  DateTime? @map("decision_at")
  publishedAt DateTime? @map("published_at")

  author  User                        @relation("MedPublisherSubmissionAuthor", fields: [createdBy], references: [id], onDelete: Cascade)
  handlingEditor User?                @relation("MedPublisherHandlingEditor", fields: [handlingEditorId], references: [id], onDelete: SetNull)
  project Project?                    @relation("MedPublisherSubmissionProject", fields: [projectId], references: [id], onDelete: SetNull)
  reviews MedPublisherReview[]
  events  MedPublisherTimelineEvent[]

  @@index([createdBy])
  @@index([handlingEditorId])
  @@index([projectId])
  @@index([status])
  @@map("med_publisher_submissions")
}

model MedPublisherEditor {
  userId     String   @id @map("user_id")
  role       String   @default("editor")
  isActive   Boolean  @default(true) @map("is_active")
  canPublish Boolean  @default(true) @map("can_publish")
  createdBy  String?  @map("created_by")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")

  user      User  @relation("MedPublisherEditorUser", fields: [userId], references: [id], onDelete: Cascade)
  grantedBy User? @relation("MedPublisherEditorGrantedBy", fields: [createdBy], references: [id], onDelete: SetNull)

  @@index([role, isActive])
  @@index([createdBy])
  @@map("med_publisher_editors")
}

model MedPublisherReview {
  id                  String    @id @default(dbgenerated("gen_random_uuid()"))
  submissionId        String    @map("submission_id")
  reviewerId          String    @map("reviewer_id")
  status              String    @default("assigned")
  recommendation      String?
  publicComment       String?   @map("public_comment")
  confidentialComment String?   @map("confidential_comment")
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")
  submittedAt         DateTime? @map("submitted_at")

  submission MedPublisherSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  reviewer   User                   @relation("MedPublisherReviewReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)

  @@unique([submissionId, reviewerId])
  @@index([reviewerId])
  @@index([status])
  @@map("med_publisher_reviews")
}

model MedPublisherTimelineEvent {
  id          BigInt    @id @default(autoincrement())
  submissionId String   @map("submission_id")
  eventType   String    @map("event_type")
  eventLabel  String    @map("event_label")
  actorUserId String?   @map("actor_user_id")
  actorRole   String?   @map("actor_role")
  payloadJson Json      @default("{}") @map("payload_json")
  createdAt   DateTime  @default(now()) @map("created_at")

  submission MedPublisherSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  actor      User?                  @relation("MedPublisherEventActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([submissionId, createdAt])
  @@index([actorUserId])
  @@map("med_publisher_timeline_events")
}

model Document {
  id         String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId  String   @map("project_id")
  title      String
  content    String? // TEXT
  orderIndex Int      @default(0) @map("order_index")
  parentId   String?  @map("parent_id")
  createdBy  String?  @map("created_by")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @default(now()) @updatedAt @map("updated_at")
  version    Int      @default(1) // Optimistic locking

  project Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parent  Document? @relation("DocHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Document[] @relation("DocHierarchy")
  creator User?     @relation(fields: [createdBy], references: [id])
  citations Citation[]

  @@map("documents")
}

model Citation {
  id           String   @id @default(dbgenerated("gen_random_uuid()"))
  documentId   String   @map("document_id")
  articleId    String   @map("article_id")
  orderIndex   Int      @default(0) @map("order_index")
  inlineNumber Int?     @map("inline_number")
  subNumber    Int?     @default(1) @map("sub_number")
  pageRange    String?  @map("page_range")
  note         String?
  createdAt    DateTime @default(now()) @map("created_at")

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  article  Article  @relation(fields: [articleId], references: [id])

  @@map("citations")
}

model ProjectStatistic {
  id                 String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId          String   @map("project_id")
  type               String // chart, table
  title              String
  description        String?
  config             Json
  tableData          Json?    @map("table_data")
  dataClassification Json?    @map("data_classification")
  chartType          String?  @map("chart_type")
  usedInDocuments    String[] @map("used_in_documents")
  orderIndex         Int      @default(0) @map("order_index")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at")
  createdBy          String?  @map("created_by")
  version            Int      @default(1) // Optimistic locking

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User?   @relation(fields: [createdBy], references: [id])

  @@index([projectId])
  @@index([type])
  @@index([chartType])
  @@map("project_statistics")
}

model SearchQuery {
  id        String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId String   @map("project_id")
  topic     String
  filters   Json
  status    String   @default("queued")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("search_queries")
}

// Кэш данных о статьях для графа цитирований
model GraphCache {
  pmid          String    @id
  title         String?
  authors       String?
  year          Int?
  doi           String?
  referencePmids String[] @default([]) @map("reference_pmids")
  citedByPmids   String[] @default([]) @map("cited_by_pmids")
  citationCount  Int?     @map("citation_count")
  fetchedAt     DateTime? @map("fetched_at")
  expiresAt     DateTime? @default(dbgenerated("now() + interval '30 days'")) @map("expires_at")
  projectId     String?   @map("project_id")

  @@index([projectId])
  @@index([expiresAt])
  @@map("graph_cache")
}

// Отслеживание прогресса загрузки связей из PubMed
model GraphFetchJob {
  id                 String    @id @default(dbgenerated("gen_random_uuid()"))
  projectId          String    @map("project_id")
  status             String    @default("pending") // pending, running, completed, failed, cancelled
  totalArticles      Int       @default(0) @map("total_articles")
  processedArticles  Int       @default(0) @map("processed_articles")
  totalPmidsToFetch  Int       @default(0) @map("total_pmids_to_fetch")
  fetchedPmids       Int       @default(0) @map("fetched_pmids")
  startedAt          DateTime? @map("started_at")
  completedAt        DateTime? @map("completed_at")
  lastProgressAt     DateTime? @map("last_progress_at") // Время последнего обновления прогресса
  cancelledAt        DateTime? @map("cancelled_at") // Время отмены
  cancelReason       String?   @map("cancel_reason") // stalled, user_cancelled, timeout
  errorMessage       String?   @map("error_message")
  createdAt          DateTime  @default(now()) @map("created_at")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([status])
  @@map("graph_fetch_jobs")
}

// Файлы проекта (хранятся в S3-совместимом хранилище)
model ProjectFile {
  id                String   @id @default(dbgenerated("gen_random_uuid()"))
  projectId         String   @map("project_id")
  name              String   // Оригинальное имя файла
  storagePath       String   @map("storage_path") // Путь в S3: {projectId}/{uuid}.{ext}
  mimeType          String   @map("mime_type")
  size              Int      // Размер в байтах
  category          String   @default("other") // document, image, video, audio, other
  description       String?
  usedInDocuments   String[] @default([]) @map("used_in_documents") // ID документов где используется
  uploadedBy        String?  @map("uploaded_by")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at")
  extractedMetadata Json?    @map("extracted_metadata") // Cached AI-extracted metadata
  extractedText     String?  @map("extracted_text") // Cached full text from PDF/Word
  extractionDate    DateTime? @map("extraction_date") // When metadata was extracted

  project  Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  uploader User?   @relation(fields: [uploadedBy], references: [id])

  @@index([projectId])
  @@index([category])
  @@map("project_files")
}

// ===== Admin Panel Models =====

model UserActivity {
  id              String   @id @default(dbgenerated("gen_random_uuid()"))
  userId          String   @map("user_id")
  sessionId       String   @map("session_id") @db.Uuid
  actionType      String   @map("action_type") @db.VarChar(50)
  actionDetail    Json?    @map("action_detail")
  ipAddress       String?  @map("ip_address") @db.VarChar(45)
  userAgent       String?  @map("user_agent")
  createdAt       DateTime @default(now()) @map("created_at")
  durationSeconds Int      @default(0) @map("duration_seconds")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([actionType])
  @@index([sessionId])
  @@map("user_activity")
}

model UserSession {
  id             String    @id @default(dbgenerated("gen_random_uuid()"))
  userId         String    @map("user_id")
  startedAt      DateTime  @default(now()) @map("started_at")
  endedAt        DateTime? @map("ended_at")
  lastActivityAt DateTime  @default(now()) @map("last_activity_at")
  ipAddress      String?   @map("ip_address") @db.VarChar(45)
  userAgent      String?   @map("user_agent")
  isActive       Boolean   @default(true) @map("is_active")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startedAt])
  @@index([isActive])
  @@map("user_sessions")
}

model SystemErrorLog {
  id            String    @id @default(dbgenerated("gen_random_uuid()"))
  errorType     String    @map("error_type") @db.VarChar(100)
  errorMessage  String    @map("error_message")
  errorStack    String?   @map("error_stack")
  userId        String?   @map("user_id")
  requestPath   String?   @map("request_path") @db.VarChar(500)
  requestMethod String?   @map("request_method") @db.VarChar(10)
  requestBody   Json?     @map("request_body")
  ipAddress     String?   @map("ip_address") @db.VarChar(45)
  createdAt     DateTime  @default(now()) @map("created_at")
  resolved      Boolean   @default(false)
  resolvedAt    DateTime? @map("resolved_at")
  resolvedBy    String?   @map("resolved_by")
  notes         String?

  user     User? @relation("UserErrors", fields: [userId], references: [id], onDelete: SetNull)
  resolver User? @relation("ResolvedBy", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([createdAt])
  @@index([errorType])
  @@index([resolved])
  @@map("system_error_logs")
}

model SubscriptionPlan {
  id            Int      @id @default(autoincrement())
  name          String   @db.VarChar(100)
  description   String?
  priceMonthly  Decimal? @map("price_monthly") @db.Decimal(10, 2)
  priceYearly   Decimal? @map("price_yearly") @db.Decimal(10, 2)
  features      Json     @default("{}")
  maxProjects   Int?     @map("max_projects")
  maxDocuments  Int?     @map("max_documents")
  maxStorageMb  Int?     @map("max_storage_mb")
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")

  subscriptions UserSubscription[]

  @@map("subscription_plans")
}

model UserSubscription {
  id            String    @id @default(dbgenerated("gen_random_uuid()"))
  userId        String    @map("user_id")
  planId        Int?      @map("plan_id")
  status        String    @default("free") @db.VarChar(20)
  startedAt     DateTime  @default(now()) @map("started_at")
  expiresAt     DateTime? @map("expires_at")
  paymentMethod String?   @map("payment_method") @db.VarChar(50)
  createdAt     DateTime  @default(now()) @map("created_at")

  user User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan SubscriptionPlan? @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([status])
  @@map("user_subscriptions")
}

model AdminAuditLog {
  id         String   @id @default(dbgenerated("gen_random_uuid()"))
  adminId    String   @map("admin_id")
  action     String   @db.VarChar(100)
  targetType String?  @map("target_type") @db.VarChar(50)
  targetId   String?  @map("target_id") @db.VarChar(100)
  details    Json?
  ipAddress  String?  @map("ip_address") @db.VarChar(45)
  createdAt  DateTime @default(now()) @map("created_at")

  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([createdAt])
  @@map("admin_audit_log")
}
